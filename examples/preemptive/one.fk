include std

-- An attempt at pre-emptive concurrency.


interface Stop = stop : Unit

interface Go = go : Unit

interface PromiseStop = promiseStop : {Unit -> [RefState, PromiseGo, AwaitGo, PromiseStop, Console]Unit} -> Unit

interface PromiseGo = promiseGo : {Unit -> [RefState, PromiseGo, AwaitGo, PromiseStop, Console]Unit} -> Unit

interface AwaitGo = awaitGo : Ref (Maybe Unit) -> Maybe Unit

waitForStop : {[PromiseStop, Console, PromiseGo, RefState, AwaitGo]Unit}
-- First we wait for the stop signal to come in.
-- This wait is done non-blocking.
waitForStop! = promiseStop { _ ->
                            -- When we receive stop we have to stop computing.
                            -- Hence we make a new promise for Go and await
                            -- this.
                            let res = new nothing in
                            promiseGo {p -> write res (just unit); unit};
                            -- promiseGo {p -> new nothing; unit};
                            awaiter res;
                            -- When we receive Go, we start computing again
                            -- and reinstall the stop waiter.
                            waitForStop!}

counter : {Int -> [Console]Unit}
counter x = ouint x;
            sleep 250000;
            counter (x + 1)

thread : {[PromiseStop, Console, PromiseGo, RefState, AwaitGo]Unit}
thread! = waitForStop!; counter 0

controller : {[Stop, Go, Console]Unit}
controller! = stop!; print "*- stop\n"; sleep 500000; print "*- go\n"; go!; sleep 500000; controller!

awaiter : {Ref (Maybe Unit) -> [AwaitGo, Console]Unit}
awaiter cell = case (awaitGo cell) { nothing  -> -- print "\n Restarting await\n";
                                                 awaiter cell
                                   | (just x) -> --print "\n Exiting Await\n";
                                                 x }

sch : {Maybe {Unit -> [RefState, PromiseGo, AwaitGo, PromiseStop, Console]Unit}    -- stopper
    -> Maybe {Unit -> [RefState, PromiseGo, AwaitGo, PromiseStop, Console]Unit}    -- goer
    -> <PromiseStop, PromiseGo, AwaitGo>Unit
    -> <Stop, Go>Unit
    -> [Console, RefState]Unit}

-- Installing Promises
sch _ goer <promiseStop stpr -> thread> <control> =
    print "stop installed\n";
    sch (just stpr) goer (thread unit) control!

sch stpr _ <promiseGo goer -> thread> <control> =
    -- print "go installed";
    sch stpr (just goer) (thread unit) control!

-- Executing promises
sch (just stpr) goer <thread> <stop -> control> =
    sch nothing goer (stpr unit; thread!) (control unit)

-- This is necessary as otherwise we can't advance past this.
-- Not sure why this is the case...
sch stpr (just goer) <awaitGo cell -> thread> <go -> control> =
    -- print "\nhandling go 2\n";
    sch stpr nothing (goer unit; thread (read cell)) (control unit)

sch stpr (just goer) <thread> <go -> control> =
    -- print "\nhandling go\n";
    sch stpr nothing (goer unit; thread!) (control unit)

sch nothing goer <thread> <stop -> control> =
    sch nothing goer thread! (control unit)

sch stpr nothing <thread> <go -> control> =
    -- print "gone";
    sch stpr nothing thread! (control unit)


-- Awaiting
sch stpr goer <awaitGo cell -> thread> <control> =
    -- print "awaiting\n";
    sch stpr goer (thread (read cell)) control!

-- Finishing
sch _ _ unit _ = print "\nThread finished"
sch _ _ _ unit = print "\nController finished"


main : {[Console, RefState]Unit}
main! = sch nothing nothing thread! controller!
